# User Story Mapping (Patton, 2014\)

## Read This First

User Stories are *talking points* and not *writing points*. Their purpose is to facilitate conversations, often not about *what* we're doing but *why* we're doing it and the impact it could have.

The author uses outputs and outcomes in the same way as they would in the charity sector. "Impact" however, is kind of a bigger outcome, so I prefer to think of it as the outcomes for stakeholders other than your immediate users and clients. In PK/PD software, the users are consultants, academics and drug companies, but the true impact is felt by the patients.

Key points:

* Shared documents are not shared understanding  
* Understanding is the goal, not documentation  
* Document the story mapping *process* so that ideas and context are captured and not lost or forgotten  
* Your job is to change the world (for your users and the users' users and the users' users' users and so on, until the final destination \- if you can say there is one)  
* Your company won't get what it wants unless your customers get what they want  
* There's always more to build than we have resources to build  
* Minimize output; maximize impact. (Or "less buck; more bang")

(This reminds me of Simon Willison's blog at [https://simonwillison.net/2025/Jul/13/django-birthday/\#django-birthday19.jpg](https://simonwillison.net/2025/Jul/13/django-birthday/#django-birthday19.jpg) : "Wouldn't it be cool if..." though I suspect that's more at a feature level than the current discussion.)

## The Big Picture

Key points:

* Stories get their name from how they're used, not how they're written  
* Story maps are for breaking down big stories as you tell them  
* Talk and Doc: write cards or sticky notes to externalize thoughts as you think them  
* Think-Write-Explain-Place (reminds me of Think-Jot-Pair-Share. There's probably a modification I could implement.)  
* Map out the idea (the "why") and then move onto customers and users. Map out how they will use your product, a day-in-the-life, and so on.  
* Lay cards out horizontally to indicate sequence and ordering in time; use phrases such as "and then..." to fill in the gaps  
* Lay cards out vertically to indicate level of detail and alternatives; use phrases such as "or they might..." to fill in the gaps  
* Go breadth-first and add details later

## Plan to do Less

There is always more work than resources, so slice out plans in stages to limit the amount of work between releases.

Focus on outcomes (what users get) rather than features (what you give) and slice out releases that get those outcomes.

Slice out a Minimum Viable Product, which is the smallest product that will allow you to *learn* what you need, or to prove/disprove assumptions.

Plan several releases ahead, each focussing on one or two outcomes.

## Plan to Learn Faster

* Start by discussing the opportunity  
* Validate the problem (and that the problem you think exists really does)  
* Prototype to learn, fast, whether your solution is valuable and usable  
* Watch out for what people say they want; judge them by their actions, not their words. (e.g., do they use your prototype?)  
* Build to learn; create whatever will teach you the most in the least amount of time.  
* Iterate until viable; *grow* it, don't build it.

Here, the author uses a diagram of "the evolution of software," starting with a skateboard, then a scooter, then a bicycle, then a motorbike and then a car. At every stage, the (Agile?) product gets someone from A to B; the only difference is the degree of utility.

In contrast, there is another diagram that shows one wheel, then two, then wheels with a body and finally a complete car. In this (waterfall) system, nothing is useful until the very end, by which time the environment and market could have changed dramatically.

Validating learning follows a Build-Measure-Learn cycle.

Minimize experiments to spend less time building and more time learning.

## Plan to Finish On-Time

* The secret to good estimation is to trust estimates from people who really know what they're doing.  
* Share estimates among the group to get maximum feedback.  
* Don't release every slice in your plan; improving by iteration can exist between releases.  
* Manage your budget  
* Iterative thinking evaluates changes; incremental thinking makes additions.  
* Split slices into opening-, mid- and end-game. (I'd need more time to make notes on this.)

## You Already Know How

(TBC)

